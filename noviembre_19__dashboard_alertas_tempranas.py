# -*- coding: utf-8 -*-
"""noviembre 19_ Dashboard_Alertas_tempranas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a3MoWlegu7vsJErJUrpU4tA9ES4wIRQe

Confguración incial
"""

# --- LIBRERÍAS PRINCIPALES ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Visualización bonita
sns.set(style="whitegrid")
plt.rcParams["figure.figsize"] = (10,5)

print("Colab listo.")

"""Cargar archivo CVS"""

sheet_id = "1uYVrZU-DhCiEwqkpToGDlVBuTB5LVFNBQV2-18N_YBU"
sheet_name = "Respuestas de formulario 1"
sheet_name_url = sheet_name.replace(" ", "%20")

url = f"https://docs.google.com/spreadsheets/d/{sheet_id}/gviz/tq?tqx=out:csv&sheet={sheet_name_url}"

df = pd.read_csv(url)
df.head()

print("Columnas originales:")
print(df.columns.tolist())

# Limpiar nombres (opcional)
df.columns = df.columns.str.strip()

"""Seleccion de columnas clave"""

col_asignatura = "Por favor seleccione el curso"
col_fecha = "Marca temporal"
col_preg1 = "¿Cuál cree que es la principal razón por su bajo desempeño en el primer previo de este curso?"
col_preg2 = "¿Alguna otra razón por la cual tuvo bajo desempeño en el primer previo de este curso?"

df_filtered = df[[col_asignatura, col_fecha, col_preg1, col_preg2]]
df_filtered.head()

"""Convertir la fecha"""

df_filtered[col_fecha] = pd.to_datetime(df_filtered[col_fecha], errors="coerce")
df_filtered["Año"] = df_filtered[col_fecha].dt.year
df_filtered["Mes"] = df_filtered[col_fecha].dt.month

"""Frecuecnia por asignatura"""

!pip install -q ipywidgets

"""`*`*`Cantidad de reportes por asignatura`*`*`"""

from google.colab import output
output.enable_custom_widget_manager()

import ipywidgets as widgets
from IPython.display import display

df_filtered[col_fecha] = pd.to_datetime(df_filtered[col_fecha], errors="coerce")
df_filtered["Año"] = df_filtered[col_fecha].dt.year
df_filtered["Mes"] = df_filtered[col_fecha].dt.month

import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display

# CONFIGURACIÓN GLOBAL DE ESTILO
plt.rcParams.update({
    "font.family": "DejaVu Sans",       # Cambiar tipografía
    "font.size": 10,                    # Tamaño general
    "axes.titlesize": 16,               # Tamaño del título
    "axes.labelsize": 14,               # Tamaño de etiquetas
    "xtick.labelsize": 9,
    "ytick.labelsize": 9,
})

# Colores personalizados (puedes cambiar estos)
color_barras = "#a00017"   # Rojo profesional
color_titulo = "#420009"   # Negro Gris oscuro
color_ejes = "#36050c"

# --- Filtros de año y mes ---
anio_filtro = widgets.Dropdown(
    options=sorted(df_filtered["Año"].dropna().unique()),
    description='Año:',
    value=sorted(df_filtered["Año"].dropna().unique())[0],
)

mes_filtro = widgets.Dropdown(
    options=sorted(df_filtered["Mes"].dropna().unique()),
    description='Mes:',
    value=sorted(df_filtered["Mes"].dropna().unique())[0],
)

# --- Filtro múltiple de asignaturas ---
asignatura_filtro = widgets.SelectMultiple(
    options=sorted(df_filtered[col_asignatura].dropna().unique()),
    description='Asignaturas:',
    value=tuple(sorted(df_filtered[col_asignatura].dropna().unique())[:1]),
    rows=5
)

# --- Función para actualizar gráfico ---
def actualizar_grafico(año, mes, asignaturas):
    # Filtrar por año y mes
    df_f = df_filtered[(df_filtered["Año"] == año) & (df_filtered["Mes"] == mes)]

    # Filtrar por asignaturas seleccionadas
    if asignaturas:
        df_f = df_f[df_f[col_asignatura].isin(asignaturas)]

    # Validación
    if df_f.empty:
        print("No hay datos para este filtro.")
        return

    # Crear figura
    plt.figure(figsize=(8,6))

    # Gráfico de barras con color personalizado
    df_f[col_asignatura].value_counts().plot(
        kind="bar",
        color=color_barras,
        edgecolor="black"
    )

    # Personalizar título
    plt.title(
        f"Cantidad de reportes por asignatura ({año}-{mes})",
        color=color_titulo,
        fontweight="bold"
    )

    # Etiquetas
    plt.ylabel("Frecuencia", color=color_ejes)
    plt.xlabel("Asignatura", color=color_ejes)

    # Rotación de texto
    plt.xticks(rotation=45, ha="right")

    # Activar grid
    plt.grid(axis="y", linestyle="--", alpha=0.4)

    plt.tight_layout()

    # Guardar PDF con estilo
    filename = f"grafica_asignatura_{año}_{mes}.pdf"
    plt.savefig(filename, format="pdf", bbox_inches="tight")
    print(f"Gráfica guardada como: {filename}")

    plt.show()

# --- Mostrar widgets + vincular ---
widgets.interact(
    actualizar_grafico,
    año=anio_filtro,
    mes=mes_filtro,
    asignaturas=asignatura_filtro
)

"""`guardar la grafica en PDF`"""

plt.savefig("mi_grafica.pdf", format="pdf", bbox_inches="tight")
plt.show()

# Estas variables ya definidas:
# col_asignatura, col_preg1, col_fecha, df_filtered

df_filtered[col_fecha] = pd.to_datetime(df_filtered[col_fecha], errors="coerce")
df_filtered["Año"] = df_filtered[col_fecha].dt.year
df_filtered["Mes"] = df_filtered[col_fecha].dt.month

!pip install -q ipywidgets
from google.colab import output
output.enable_custom_widget_manager()

"""***Razones del bajo desempeño***


"""

import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display
import textwrap  # <-- para partir el texto en varias líneas

# ============================================================
#   CONFIGURACIÓN GLOBAL DE ESTILO (EDITA ESTOS VALORES)
# ============================================================

plt.rcParams.update({
    "font.family": "DejaVu Sans",   # Cambiar tipografía ('Arial', 'Calibri', etc.)
    "font.size": 12,                # Tamaño general
    "axes.titlesize": 16,           # Tamaño del título
    "axes.labelsize": 12,           # Tamaño de etiquetas de ejes
    "xtick.labelsize": 8,           # Tamaño letras en eje X
    "ytick.labelsize": 8,           # Tamaño letras en eje Y
})

color_barras = "#a00017"           # Color de las barras
color_titulo = "#2c2c2c"           # Color del título
color_ejes = "#333333"             # Color de etiquetas y ejes
grid_alpha = 0.4                   # Transparencia del grid
fig_width = 8                      # Ancho de la figura
fig_height = 5                     # Alto de la figura

# ============================================================
#                   FILTROS
# ============================================================

anio_filtro = widgets.Dropdown(
    options=sorted(df_filtered["Año"].dropna().unique()),
    description='Año:',
    value=sorted(df_filtered["Año"].dropna().unique())[0],
)

mes_filtro = widgets.Dropdown(
    options=sorted(df_filtered["Mes"].dropna().unique()),
    description='Mes:',
    value=sorted(df_filtered["Mes"].dropna().unique())[0],
)

asignatura_filtro = widgets.SelectMultiple(
    options=sorted(df_filtered[col_asignatura].dropna().unique()),
    description='Asignaturas:',
    value=(sorted(df_filtered[col_asignatura].dropna().unique())[0],),
    rows=6
)

# ============================================================
#          FUNCIÓN PARA ACTUALIZAR LA GRÁFICA
# ============================================================

def actualizar_grafico_multi(año, mes, asignaturas):

    if not asignaturas:
        print("Selecciona al menos una asignatura.")
        return

    df_f = df_filtered[
        (df_filtered["Año"] == año) &
        (df_filtered["Mes"] == mes) &
        (df_filtered[col_asignatura].isin(asignaturas))
    ]

    if df_f.empty:
        print("No hay datos para este filtro.")
        return

    # Crear figura con tamaño personalizado
    plt.figure(figsize=(fig_width, fig_height))

    # Gráfico personalizado
    ax = df_f[col_preg1].value_counts().plot(
        kind="bar",
        color=color_barras,
        edgecolor="black"
    )

    # Título personalizado
    plt.title(
        f"Razones del bajo desempeño\nAño: {año}, Mes: {mes}, Asignaturas: {len(asignaturas)} seleccionadas",
        color=color_titulo,
        fontweight="bold"
    )

    # Etiquetas de ejes
    plt.ylabel("Frecuencia", color=color_ejes)
    plt.xlabel("Razón", color=color_ejes)

    # ====== PARTIR EL TEXTO DE LAS ETIQUETAS EN VARIAS LÍNEAS ======
    # Ajusta "width" para controlar cuántos caracteres por línea (más pequeño = más renglones)
    new_labels = []
    for label in ax.get_xticklabels():
        texto = label.get_text()
        # divide el texto en líneas de ~30 caracteres
        wrapped = textwrap.fill(texto, width=40)
        new_labels.append(wrapped)
    ax.set_xticklabels(new_labels, rotation=35, ha="center")
    # ================================================================

    # Grid
    plt.grid(axis="y", linestyle="--", alpha=grid_alpha)

    plt.tight_layout()

    # ================== GUARDAR EN PDF ======================
    filename = f"grafica_razones_{año}_{mes}.pdf"
    plt.savefig(filename, format="pdf", bbox_inches="tight")
    print(f"Gráfica guardada como: {filename}")
    # =======================================================

    plt.show()

# ============================================================
#         MOSTRAR FILTROS + GRÁFICA INTERACTIVA
# ============================================================

widgets.interact(
    actualizar_grafico_multi,
    año=anio_filtro,
    mes=mes_filtro,
    asignaturas=asignatura_filtro
)

"""**Asignatura vs Razón**"""

!pip install ipywidgets
from google.colab import output
output.enable_custom_widget_manager()

import ipywidgets as widgets
import matplotlib.pyplot as plt
import seaborn as sns
from IPython.display import display
import textwrap  # para partir texto de etiquetas

# --- FILTRO DE AÑO ---
anio_filtro = widgets.Dropdown(
    options=sorted(df_filtered["Año"].dropna().unique()),
    description='Año:',
    value=sorted(df_filtered["Año"].dropna().unique())[0],
)

# --- FILTRO DE ASIGNATURAS ---
asignatura_filtro = widgets.SelectMultiple(
    options=sorted(df_filtered[col_asignatura].dropna().unique()),
    description='Asignaturas:',
    value=tuple(sorted(df_filtered[col_asignatura].dropna().unique())[:1]),
    rows=8
)

# --- FUNCIÓN PARA ACTUALIZAR HEATMAP ---
def actualizar_heatmap(año, asignaturas):
    if not asignaturas:
        print("Selecciona al menos una asignatura.")
        return

    # Filtrar DataFrame
    df_f = df_filtered[
        (df_filtered["Año"] == año) &
        (df_filtered[col_asignatura].isin(asignaturas))
    ]

    if df_f.empty:
        print("No hay datos para este filtro.")
        return

    # Tabla Crosstab
    tabla = pd.crosstab(df_f[col_asignatura], df_f[col_preg1])

    # Crear figura
    plt.figure(figsize=(12, 8))
    ax = sns.heatmap(tabla, annot=True, fmt="d", cmap="Reds")

    plt.title(f"Asignatura vs Razón del bajo desempeño (Año: {año})", fontsize=16)
    plt.xlabel("Razón", fontsize=10)
    plt.ylabel("Asignatura", fontsize=14)

    # ================================
    # AJUSTE DE LABELS EN VARIAS LÍNEAS
    # ================================
    new_labels = []
    for label in ax.get_xticklabels():
        texto = label.get_text()
        wrapped = textwrap.fill(texto, width=30)  # Ajustar # caracteres por línea
        new_labels.append(wrapped)

    ax.set_xticklabels(new_labels, rotation=30, ha="center")

    plt.tight_layout()

    # ================================
    # GUARDAR EN PDF
    # ================================
    filename = f"heatmap_asignaturas_{año}.pdf"
    plt.savefig(filename, format="pdf", bbox_inches="tight")
    print(f"Heatmap guardado como: {filename}")

    plt.show()

# --- MOSTRAR FILTROS + HEATMAP ---
widgets.interact(
    actualizar_heatmap,
    año=anio_filtro,
    asignaturas=asignatura_filtro
)

"""**Nube de palabras**"""

!pip install -q wordcloud
from wordcloud import WordCloud
import matplotlib.pyplot as plt
import nltk
from nltk.corpus import stopwords
import string
from collections import Counter

# ---------------------------
# Descargar stopwords en español (solo la primera vez)
# ---------------------------
nltk.download('stopwords')

# Stopwords base del español
stopwords_es = set(stopwords.words('spanish'))

# Stopwords adicionales para encuestas
# Nota: dejo fuera "no" para que aparezcan expresiones tipo "no estudio", "no entendí"
stopwords_extra = {
    "me", "si","hay", "porque","suficiente", "ya", "solo", "más", "menos",
    "muy", "puede", "puedo", "fue", "soy", "estoy", "era", "esta", "ese", "eso",
    "lo", "la", "las", "los", "el", "un", "una", "uno", "unos", "unas",
    "al", "del", "de", "por", "con", "para", "sin", "sobre", "entre",
    "que", "se", "yo", "tu", "mi"
}

stopwords_total = stopwords_es.union(stopwords_extra)

# ---------------------------
# Construir texto base
# ---------------------------
texto = " ".join(df_filtered[col_preg1].dropna())

# Normalizar texto
texto = texto.lower()
texto = texto.translate(str.maketrans("", "", string.punctuation))

tokens = texto.split()

# ---------------------------
# 1) Crear lista de palabras "limpias"
# ---------------------------
palabras_filtradas = [
    t for t in tokens
    if t not in stopwords_total and len(t) > 2
]

# ---------------------------
# 2) Crear BIGRAMAS (frases de 2 palabras)
#    para mejorar la "redacción" de lo que se ve en la nube
# ---------------------------
bigramas = []
for w1, w2 in zip(tokens, tokens[1:]):
    # descartamos bigramas formados solo por stopwords
    if (w1 not in stopwords_total or w2 not in stopwords_total) \
       and len(w1) > 2 and len(w2) > 2:
        bigramas.append(f"{w1} {w2}")

# ---------------------------
# 3) Combinar palabras y frases para la nube
#    (puedes ponderar: por ejemplo, dar más importancia a las frases)
# ---------------------------
frecuencias = Counter()

# Unigramas (palabras sueltas)
for palabra in palabras_filtradas:
    frecuencias[palabra] += 1

# Bigramas (frases de dos palabras) - se les puede dar un "peso extra"
for bg in bigramas:
    frecuencias[bg] += 2   # peso 2 para que las frases ganen protagonismo

# Si quieres SOLO frases, comenta el bloque de unigramas de arriba.

if not frecuencias:
    print("No hay palabras significativas después de la limpieza.")
else:
    # ---------------------------
    # Generar WordCloud desde frecuencias
    # ---------------------------
    wordcloud = WordCloud(
        width=900,
        height=500,
        background_color="white",
        colormap="Reds",
        max_words=300
    ).generate_from_frequencies(frecuencias)

    # ---------------------------
    # Mostrar y GUARDAR EN PDF
    # ---------------------------
    plt.figure(figsize=(14, 6))
    plt.imshow(wordcloud, interpolation="bilinear")
    plt.axis("off")
    plt.title("Nube de palabras sobre causas del bajo desempeño", fontsize=16)

    filename = "nube_palabras_bajo_desempeno.pdf"
    plt.savefig(filename, format="pdf", bbox_inches="tight")
    print(f"Nube de palabras guardada como: {filename}")

    plt.show()

"""Creando dashboard version web"""

df_filtered.to_csv("datos_alertas.csv", index=False)

app_code = """
import streamlit as st
import pandas as pd
import plotly.express as px

st.set_page_config(layout="wide")

st.title("Sistema de Alertas Tempranas – Ingeniería Electrónica")

df = pd.read_csv("datos_alertas.csv")

anio = st.selectbox("Año", sorted(df["Año"].unique()))
mes = st.selectbox("Mes", sorted(df["Mes"].unique()))

asignaturas = st.multiselect(
    "Asignaturas",
    sorted(df["Asignatura"].unique())
)

df_f = df[(df["Año"] == anio) & (df["Mes"] == mes)]
if asignaturas:
    df_f = df_f[df_f["Asignatura"].isin(asignaturas)]

conteo = df_f["Asignatura"].value_counts().reset_index()
conteo.columns = ["Asignatura", "Frecuencia"]

fig = px.bar(
    conteo,
    x="Asignatura",
    y="Frecuencia",
    text="Frecuencia"
)

st.plotly_chart(fig, use_container_width=True)
"""

with open("app.py", "w") as f:
    f.write(app_code)

!pip install streamlit plotly pandas